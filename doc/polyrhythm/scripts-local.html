
<script>
// vim: ts=3:ft=javascript

//////////////////////////////
//
// loadDefaultSettings --
//

function loadDefaultSettings() {
	SETTINGS = JSON.parse(JSON.stringify(DEFAULTS));
}



//////////////////////////////
//
// loadCgiSettings --
//

function loadCgiSettings() {
	let plist = getParameterList(DEFAULTS);
	let cgi = GetCgiParameters();
	for (let i=0; i<plist.length; i++) {
		let key = plist[i];
		if (typeof cgi[plist[i]] === "undefined") {
			continue;
		}
		SETTINGS[key] = cgi[key];
	}
}



//////////////////////////////
//
// updateInputsFromSettings --
//

function updateInputsFromSettings() {
	let inputs = document.querySelectorAll("input");
	for (let i=0; i<inputs.length; i++) {
		let id = inputs[i].id;
		if (typeof SETTINGS[id] !== "undefined") {
			inputs[i].value = SETTINGS[id];
		}
	}

	let selects = document.querySelectorAll("select");
	for (let i=0; i<selects.length; i++) {
		let id = selects[i].id;
		if (typeof SETTINGS[id] !== "undefined") {
			setSelectedIndex(selects[i], SETTINGS[id]);
		}
	}
}



////////////////////
//
// setSelectedIndex --
//

function setSelectedIndex(select, value) {
	for (let i=0; i<select.options.length; i++) {
		if (select.options[i].value == value) {
			select.options[i].selected = true;
			return;
		}
	}
}



//////////////////////////////
//
// getParameterValue --
//

function getParameterValue(parameter) {
	return SETTINGS[parameter];
}



//////////////////////////////
//
// getParameterList --
//

function getParameterList(obj) {
	if (!obj) {
		return [];
	}
	let output = Object.getOwnPropertyNames(obj);
	return output;
}



//////////////////////////////
//
// makeUrl --
//

function makeUrl() {
	let params = getParameterList(DEFAULTS);
	let outlist = [];
	// Store any parameters in SETTINGS that are not the same as DEFAULTS:
	for (let i=0; i<params.length; i++) {
		let key = params[i];
		if (DEFAULTS[key] == SETTINGS[key]) {
			continue;
		}
		let value = SETTINGS[key];
		let entry = key + "=" + encodeURIComponent(value);
		outlist.push(entry);
	}
	if (outlist.length == 0) {
		return "";
	}

	let url = window.location.href.replace(/\?.*/, "");
	if (outlist.length > 0) {
		url += "?" + outlist[0];
	}
	for (let i=1; i<outlist.length; i++) {
		url += "&" + outlist[i];
	}
	return url;
}



//////////////////////////////
//
// generateScore --
//

function generateScore() {
	updateSettingsFromInput();
	if (SETTINGS.layout === "serial") {
		generateScoreSerial();
	} else {
		generateScoreParallel();
	}
}


//////////////////////////////
//
// generateScoreParallel --
//

function generateScoreParallel() {
	let editor = document.querySelector("script#inputdata-polyrhythm");
	let editor2 = document.querySelector("script#polyrhythm");
	if (!editor) {
		return;
	}
	if (!editor2) {
		return;
	}
	let parts = getParts();
	if (parts.length == 0) {
		editor.textContent = "";
		editor2.textContent = "";
		return;
	}

	let tempo = SETTINGS.tempo;

	let output = "";
	let drumcount = 0;
	let ratiocount = 0;
	let tempoprinted = 0;

	// Print exclusive interpretation line:
	output += "**dtime";
	for (let i=0; i<parts.length; i++) {
		output += "\t";
		if (parts[i].drum) {
			output += "**drum";
			drumcount++;
		} else {
			ratiocount++;
			output += "**ratio";
		}
	}
	output += "\n";

	output += printMeasure(0, parts);

	// Print instrument info:
	if (ratiocount > 0) {
		if (!tempoprinted) {
			output += "*MM" + tempo;
			tempoprinted = 1;
		} else {
			output += "*";
		}
		for (let i=0; i<parts.length; i++) {
			if (parts[i].drum) {
				output += "\t*";
			} else {
				output += "\t*I#" + parts[i].instrument;
			}
		}
		output += "\n";
	}


	// Print reference pitch info:
	if (ratiocount > 0) {
		if (!tempoprinted) {
			output += "*MM" + tempo;
			tempoprinted = 1;
		} else {
			output += "*";
		}
		for (let i=0; i<parts.length; i++) {
			if (parts[i].drum) {
				output += "\t*";
			} else {
				output += "\t*ref:" + parts[i].ref;
			}
		}
		output += "\n";
	}


	// Print tempo if it is missing:
	if (!tempoprinted) {
		tempoprinted = 1;
		output += "*MM" + tempo;
		for (let i=0; i<parts.length; i++) {
			output += "\t*" + parts[i].cycles;
		}
		output += "\n";
	}

	output += printMeasure(1, parts);

	// Print data lines:
	let linecount = 1;
	for (let i=0; i<parts.length; i++) {
		let found = 0;
		for (let j=i+1; j<parts.length; j++) {
			if (parts[i].cycles == parts[j].cycles) {
				found = 1;
				break;
			}
		}
		if (!found) {
			linecount *= parts[i].cycles;
		}
	}
	linecount++;


	for (let i=0; i<linecount; i++) {
		if (i == linecount - 1) {
			output += printMeasure(2, parts);
		}
		output += "1";
		for (let j=0; j<parts.length; j++) {
			output += "\t";
			if ((i % parts[j].cycles) == 0) {
				output += parts[j].pitch;
			} else {
				output += ".";
			}
		}
		output += "\n";
	}

	output += printMeasure("=", parts);


	// Print termination line:
	output += "*-";
	for (let i=0; i<parts.length; i++) {
		output += "\t*-";
	}
	output += "\n";

	let repeats = SETTINGS.repeats;
	output += printMyank(repeats, parts);

	// print URL to create this polyrhythm score:
	let url = makeUrl();
	if (url !== "") {
		output += "!!!URL: " + url + "\n";
	}

	editor.textContent = output;
	editor2.textContent = output;
}



//////////////////////////////
//
// generateScoreSerial --
//

function generateScoreSerial() {
	let editor = document.querySelector("script#inputdata-polyrhythm");
	let editor2 = document.querySelector("script#polyrhythm");
	if (!editor) {
		return;
	}
	if (!editor2) {
		return;
	}
	let parts = getParts();
	if (parts.length == 0) {
		editor.textContent = "";
		editor2.textContent = "";
		return;
	}

	// Print data lines:
	let linecount = 1;
	for (let i=0; i<parts.length; i++) {
		let found = 0;
		for (let j=i+1; j<parts.length; j++) {
			if (parts[i].cycles == parts[j].cycles) {
				found = 1;
				break;
			}
		}
		if (!found) {
			linecount *= parts[i].cycles;
		}
	}

	let output = "";
	for (let i=0; i<parts.length; i++) {
		output += "!!!!SEGMENT:\n";
		output += printPart(parts[i], linecount);
	}

	// print URL to create this polyrhythm score:
	let url = makeUrl();
	if (url !== "") {
		output += "!!!URL: " + url + "\n";
	}

	editor.textContent = output;
	editor2.textContent = output;
}


//////////////////////////////
//
// printPart --
//

function printPart(part, sum) {
	let parts = [];
	parts.push(part);

	let tempo = SETTINGS.tempo;

	let output = "";
	let drumcount = 0;
	let ratiocount = 0;
	let tempoprinted = 0;

	// Print exclusive interpretation line:
	output += "**dtime";
	for (let i=0; i<parts.length; i++) {
		output += "\t";
		if (parts[i].drum) {
			output += "**drum";
			drumcount++;
		} else {
			ratiocount++;
			output += "**ratio";
		}
	}
	output += "\n";

	output += printMeasure(0, parts);

	// Print instrument info:
	if (ratiocount > 0) {
		if (!tempoprinted) {
			output += "*MM" + tempo;
			tempoprinted = 1;
		} else {
			output += "*";
		}
		for (let i=0; i<parts.length; i++) {
			if (parts[i].drum) {
				output += "\t*";
			} else {
				output += "\t*I#" + parts[i].instrument;
			}
		}
		output += "\n";
	}


	// Print reference pitch info:
	if (ratiocount > 0) {
		if (!tempoprinted) {
			output += "*MM" + tempo;
			tempoprinted = 1;
		} else {
			output += "*";
		}
		for (let i=0; i<parts.length; i++) {
			if (parts[i].drum) {
				output += "\t*";
			} else {
				output += "\t*ref:" + parts[i].ref;
			}
		}
		output += "\n";
	}


	// Print tempo if it is missing:
	if (!tempoprinted) {
		tempoprinted = 1;
		output += "*MM" + tempo;
		for (let i=0; i<parts.length; i++) {
			output += "\t*" + parts[i].cycles;
		}
		output += "\n";
	}

	output += printMeasure(1, parts);

	let count = sum / part.cycles;
console.log("COUNT", count, "SUM", sum, "CYCLES", part.cycles);

	for (let i=0; i<count; i++) {
		output += part.cycles;
		output += "\t";
		output += part.pitch;
		output += "\n";
	}

	output += printMeasure(2, parts);

	output += "1\t" + part.pitch + "\n";

	output += printMeasure("=", parts);

	let repeats = SETTINGS.repeats;
	output += printMyank(repeats, parts);

	// Print termination line:
	output += "*-\t*-\n";

	return output;
}


//////////////////////////////
//
// printMyank --
//

function printMyank(repeats, parts) {
	let output = "";
	output += "!!!filter: myank -m 0";
	output += ",1*" + repeats;
	output += ",2";
	output += "\n";
	return output;
}


//////////////////////////////
//
// printMeasure --
//

function printMeasure(tag, parts) {
	let output = "";
	output += "=" + tag;
	for (let i=0; i<parts.length; i++) {
		output += "\t";
		output += "=" + tag;
	}
	output += "\n";
	return output;
}



//////////////////////////////
//
// getParts --
//

function getParts() {
	let output = [];
	let maxcount = 5;
	for (let i=0; i<maxcount; i++) {
		let cycles = SETTINGS["cycle-" + (i+1)];
		if (cycles <= 0) {
			continue;
		}
		let entry = {};
		entry.number = i+1;
		if (cycles.match(/^\s*\d/)) {
			entry.cycles = parseInt(cycles);
		} else {
			entry.cycles = 1;
		}
		entry.drum = 0;
		let instrument = SETTINGS["timbre-" + (i+1)];
		if (instrument < 0) {
			entry.drum = 1;
			entry.pitch = -instrument;
			entry.instrument = -1;
		} else {
			entry.drum = 0;
			entry.pitch = SETTINGS["pitch-" + (i+1)];
			entry.instrument = instrument;
			entry.ref = SETTINGS["ref-" + (i+1)];
		}
		output.push(entry);
	}
	return output;
}



//////////////////////////////
//
// updateSettingsFromInput --
//

function updateSettingsFromInput() {
	let inputs = document.querySelectorAll("input");
	for (let i=0; i<inputs.length; i++) {
		let id = inputs[i].id;
		if (typeof SETTINGS[id] !== "undefined") {
			SETTINGS[id] = inputs[i].value;
		}
	}

	let selects = document.querySelectorAll("select");
	for (let i=0; i<selects.length; i++) {
		let id = selects[i].id;
		if (typeof SETTINGS[id] !== "undefined") {
			SETTINGS[id] = selects[i].value;
		}
	}
}


</script>



