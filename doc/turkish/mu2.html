


<script>
//
// Programmer:    Craig Stuart Sapp <craig.stanford.edu>
// Creation Date: Thu Apr 29 09:09:11 PDT 2021
// Last Modified: Thu Apr 29 09:09:14 PDT 2021
// Filename:      mu2.html
// Syntax:        Javascript 6
// vim:           ts=3:ft=javascript
//
// Description:   Converter from mu2 to ratioscore.
//


//////////////////////////////
//
// convertMu2FileToRatioscore -- 
//
// Line types:
//   1 = cue note (not sung)
//   4 = note with glissando to next note
//   7 = note with tremolo
//   8 = grace note
//   9 = regular note/rest (if there is a note name and duration
//        otherwise a section marker?
//  10 = note with grace note after it
//  12 = trilled note
//  21 = blank line?
//  23 = mordent on note
//

function convertMu2FileToRatioscore(mu2file, filename) {
	if (!mu2file) {
		return "";
	}

	let fileinfo = FILEINFO[filename];

	let lines = mu2file.split("\n");
	let composer = getNumberContent(lines, 58).replace(/\s*$/, "");
	let lyricist = getNumberContent(lines, 59).replace(/\s*$/, "");
	let title    = getNumberContent(lines, 60).replace(/\s*$/, "");
	let meter    = getMeter(lines);
	let tempo    = getTempo(lines);

	let makam    = fileinfo.MAKAM || "";
	let form     = fileinfo.FORM  || "";
	let usul     = fileinfo.USUL  || "";

	let events = [];
	// skip the first few lines, since the time signature
	// can mess up the line type analysis.
	for (let i=4; i<lines.length; i++) {
		let line = lines[i];
		let matches = line.match(/^(\d+)/);
		let linetype = -1;
		if (matches) {
			linetype = parseInt(matches[1]);
		}
		if (linetype == 1) {
			// note in accompaniment
			let event = createDurationEvent(line);
			if (event) {
				events.push(event);
			}
		} else if (linetype == 4) {
			// note with glissando after it
			let event = createDurationEvent(line);
			if (event) {
				events.push(event);
			}
		} else if (linetype == 7) {
			// note with tremolo
			let event = createDurationEvent(line);
			if (event) {
				events.push(event);
			}
		} else if (linetype == 9) {
			// note or rest
			let event = createDurationEvent(line);
			if (event) {
				events.push(event);
			}
		} else if (linetype == 8) {
			// grace note
			let event = createDurationEvent(line);
			if (event) {
				events.push(event);
			}
		} else if (linetype == 10) {
			// note with grace note after it
			let event = createDurationEvent(line);
			if (event) {
				events.push(event);
			}
		} else if (linetype == 12) {
			// trilled note
			let event = createDurationEvent(line);
			if (event) {
				events.push(event);
			}
		} else if (linetype == 23) {
			// note with mordent
			let event = createDurationEvent(line);
			if (event) {
				events.push(event);
			}
		}
	}

	// addBarlines(events, meter);

	let pitches = getPitches(events);

	let output = "";
	if (title) {
		output += "!!!OTL@@TR: " + title + "\n";
	}
	if (composer) {
		output += "!!!COM: " + composer + "\n";
		let entry = COMPOSERLIST[composer];
		if (entry) {
			if (entry.CDT) {
				output += "!!!CDT: " + entry.CDT + "\n";
			}
			if (entry.WIKIPEDIA) {
				output += "!!!URL-COM: " + entry.WIKIPEDIA + "\n";
			}
		} else {
			console.log("NO ENTRY FOR "+ composer, COMPOSERLIST[composer]);
		}
	}
	if (lyricist) {
		output += "!!!LYR: " + lyricist + "\n";
	}
	if (makam) {
		output += "!!!makam: " + makam + "\n";
	}
	if (form) {
		output += "!!!form: " + form + "\n";
	}
	if (makam) {
		output += "!!!usul: " + usul + "\n";
	}

	output += "**recip\t**ratio\n";

	if (meter) {
		output += "*M" + meter + "\t*I#25\n";
	} else {
		output += "*\t*Iclars\n";
	}

	if (tempo) {
		output += "*MM" + tempo + "\t*ref:C-1\n";
	} else {
		output += "*\t*ref:C-1\n";
	}

	for (let i=0; i<events.length; i++) {
		output += printEvent(events[i]);
	}
	output += "*-\t*-\n";

	output += printPitchRdf(pitches);

	return output;
}



//////////////////////////////
//
// addBarlines --
//

function addBarlines(events, meter) {
	// using numbers in the 10 column to control barlines now
	return;
	let bardur = getMeasureDuration(meter);
	if (!bardur) {
		return;
	}
	if ((!events) || (events.length == 0)) {
		return;
	}
	let barnum = 2;
	let checker = new RationalNumber;
	// add measure 1 at start of score
	events[0].barnum = 1;
	let sum = new RationalNumber(0, 1);
	for (let i=0; i<events.length; i++) {
		let event = events[i];
		let edur = event.dur;
		sum.addTo(edur);
		checker = sum.divide(bardur);
		if (checker.getDenominator() === 1) {
			if (i < events.length - 1) {
				events[i+1].barnum = barnum++;
			}
		}
	}
}




//////////////////////////////
//
// printPitchRdf -- Using C0 as the reference for cents.
//

function printPitchRdf(pitches) {
	let tuning = {% include_relative tuning.json %};
	let keys = Object.keys(pitches);
	let output      = "";
	let naturals    = [];
	let nonnaturals = [];
	let allnotes    = [];

	for (let i=0; i<keys.length; i++) {
		let key = keys[i];
		let matches = key.match(/^([DFLMRS][aeio]l?)(\d)([bs#])?(\d)?/);
		if (!matches) {
			console.log("ERROR PROCESSING", key);
			continue;
		}
		let diatonic   = matches[1];
		let octave     = parseInt(matches[2]);
		let accidental = matches[3];
		let accsize    = parseInt(matches[4]);
		let eq53       = tuning[diatonic]
		eq53 += octave * 53;
		if (accidental) {
			if (accidental === "b") {
				eq53 -= accsize;
			} else if (accidental === "#") {
				eq53 += accsize;
			}
		}
		let diff53 = eq53 - (-1) * 53;

		let uelement = document.querySelector("select#rdf");
		let units = "";
		if (uelement) {
			units = uelement.value;
		}
		if (units === "cents") {
			let cents = diff53 * 1200.0 / 53.0
			if (cents > 0) {
				cents = parseInt(cents * 100.0 + 0.5) / 100.0;
			} else {
				cents = -(parseInt(-cents * 100.0 + 0.5) / 100.0);
			}
			allnotes[key] = cents + "c";
			if (accidental) {
				nonnaturals[key] = cents + "c";
			} else {
				naturals[key] = cents + "c";
			}
		} else {
			let ratio = "2^(" + diff53 + "/53)";
			allnotes[key] = ratio;
			if (accidental) {
				nonnaturals[key] = ratio;
			} else {
				naturals[key] = ratio;
			}
		}

	}

	let list = [];
	let nkeys = Object.keys(allnotes);
	for (let i=0; i<nkeys.length; i++) {
		let obj = {};
		obj.key = nkeys[i];
		obj.value = allnotes[nkeys[i]];
		list.push(obj);
	}

	list.sort(function(a, b) {
		let valuea = a.value;
		let valueb = b.value;
		let comparea = 0;
		let compareb = 0;
		let matches = valuea.match(/(-?\d+\.?\d*)c/);
		if (matches) {
			comparea = parseFloat(matches[1]);
			let matches = valueb.match(/(-?\d+\.?\d*)c/);
			compareb = parseFloat(matches[1]);
		} else {
			matches = valuea.match(/2\^\((\d+)\/53\)/);
			if (!matches) {
				return 0;
			} 
			comparea = parseInt(matches[1]);
			matches = valueb.match(/2\^\((\d+)\/53\)/);
			compareb = parseInt(matches[1]);
		}
		return compareb - comparea;
	});

	// Order of accidentals/non-accidentals no longer matters
	// (longer substitution strings will be applied first.
	for (let i=0; i<list.length; i++) {
		output += "!!!RDF**ratio: ";
		output += list[i].key;
		let keylen = list[i].key.length;
		for (let j=keylen; j<6; j++) {
			output += " ";
		}
		output += " = ";
		output += list[i].value;
		output += "\n";
	}

/*
	// accidental substitutions need to go first:
	let nkeys = Object.keys(nonnaturals);
	for (let i=0; i<nkeys.length; i++) {
		output += "!!!RDF**ratio: ";
		output += nkeys[i];
		output += " = ";
		output += nonnaturals[nkeys[i]];
		output += "\n";
	}

	nkeys = Object.keys(naturals);
	for (let i=0; i<nkeys.length; i++) {
		output += "!!!RDF**ratio: ";
		output += nkeys[i];
		output += " = ";
		output += naturals[nkeys[i]];
		output += "\n";
	}
*/

	return output;
}



//////////////////////////////
//
// printEvent --
//  Type 9: note or rest
//  Type 8: grace note
//

function printEvent(event) {
	if (!event.note) {
		return "";
	}
	let output = "";

	let ntime = event.recip + "";
	let count = 1;
	if (event.repeat) {
		count = event.repeat;
		if (ntime) {
			if (count > 1) {
				let matches = ntime.match(/(\d+)/);
				if (matches) {
					let oldnum = parseInt(matches[1]);
					let newnum = oldnum * count;
					ntime = ntime.replace(oldnum + "", newnum + "");
				}
			}
		}
	}

	for (let i=0; i<count; i++) {
		if (event.grace) {
			output += "q";
		} else {
			output += ntime;
		}
		output += "\t";
		if (event.rest) {
			output += 0;
		} else {
			output += event.pitch;
		}
		output += "\n";
	}

	if (typeof event.barnum !== "undefined") {
		output += "=" + event.barnum + "\t";
		output += "=" + event.barnum;
		output += "\n";
	}

	return output;
}



//////////////////////////////
//
// createBarlineEvent --
//

function createBarlineEvent(line) {
	return null;
	let fields = line.split(/\t/);
	let o = {};
	o.type = fields[0];
	return o;
}



//////////////////////////////
//
// createDurationEvent --
//

function createDurationEvent(line) {
	let fields = line.split(/\t/);
	let o = {};
	o.type = fields[0];
	if (fields[1]) {
		o.pitch = fields[1].charAt(0).toUpperCase() + fields[1].slice(1)
	} else {
		if (fields[2]) {
			o.rest = 1;
		} else {
			return null;
		}
	}
	if (fields[2]) {
		o.top = fields[2];
		o.bot = fields[3];
	} else {
		// grace note
		if (fields[1]) {
			o.top = fields[2] || 0;
			o.bot = fields[3] || 1;
			o.grace = 1;
		} else {
			return null;
		}
	}

	if (fields[9] && fields[9].match(/^\s*\d+\s*$/)) {
		let number = parseInt(fields[9]);
		o.barnum = number + 1;
	}

	o.note = 1;

	o.legato = fields[4];
	o.bas = fields[5];
	o.vel = fields[6];
	o.dur = new RationalNumber(o.top, o.bot);
	// verses
	// then floating-point version of rhythm.

	if (o.dur.getNumerator() != o.top) {
		// tremolo repeats
		o.repeat = parseInt(o.top / o.dur.getNumerator());
	}

	if (o.dur.getNumerator() == 1) {
		o.recip = o.dur.getDenominator();
	} else if (o.dur.getNumerator() == 3) {
		o.recip = parseInt(o.dur.getDenominator()) / 2;
		o.recip += ".";
	} else if (o.dur.getNumerator() == 5) {
		// such as 5/8
		o.recip = o.dur.getDenominator() + "%" + o.dur.getNumerator();
	}
	return o;
}



//////////////////////////////
//
// getNumberContent --
//

function getNumberContent(lines, number) {
	let regstring = "^" + number + "\\s*(.*)\\s*$";
	let re = new RegExp(regstring);
	for (let i=0; i<lines.length; i++) {
		let line = lines[i];
		let matches = re.exec(line);
		if (matches) {
			return matches[1];
		}
	}
	return "";
}


//////////////////////////////
//
// getMeter --
//

function getMeter(lines) {
	for (let i=0; i<lines.length; i++) {
		let line = lines[i];
		let matches = line.match(/^51\s+(\d+)\s+(\d+)/);
		if (matches) {
			return matches[1] + "/" + matches[2];
		}
	}
	return "";
}



//////////////////////////////
//
// getTempo -- Convert to quarter note units.
//

function getTempo(lines) {
	for (let i=0; i<lines.length; i++) {
		let line = lines[i];
		let matches = line.match(/^52\s+(\d+)\s+(\d+)\s+(\d+)/);
		if (matches) {
			let top = parseInt(matches[1]);
			let bot = parseInt(matches[2]);
			let tempo = parseInt(matches[3]);
			let num = new RationalNumber(top, bot);
			let quarter = new RationalNumber(1, 4);
			let factor = quarter.divide(num);
			let rtempo = new RationalNumber(tempo, 1);
			rtempo.divideTo(factor);
			return rtempo.toFloat();
		}
	}
	return "";
}



//////////////////////////////
//
// getPitches --
//

function getPitches(events) {
	let output = {};
	let pitch;
	for (let i=0; i<events.length; i++) {
		let event = events[i];
		if (event.type != 9) {
			continue;
		}
		if (event.pitch) {
			pitch = event.pitch;
		} else {
			continue;
		}
		if (!output[pitch]) {
			output[pitch] = 1;
		} else {
			output[pitch]++;
		}
	}
	return output;
}



//////////////////////////////
//
// Returns the duration of the measure in whole-note units.
//

function getMeasureDuration(meter) {
	let output = new RationalNumber(meter);
	return output;
}




</script>



