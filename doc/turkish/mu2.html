


<script>
//
// Programmer:    Craig Stuart Sapp <craig.stanford.edu>
// Creation Date: Thu Apr 29 09:09:11 PDT 2021
// Last Modified: Thu Apr 29 09:09:14 PDT 2021
// Filename:      mu2.html
// Syntax:        Javascript 6
// vim:           ts=3:ft=javascript
//
// Description:   Converter from mu2 to ratioscore.
//


//////////////////////////////
//
// convertMu2FileToRatioscore -- 
//

function convertMu2FileToRatioscore(mu2file) {
	if (!mu2file) {
		return "";
	}
	let lines = mu2file.split("\n");
	let composer = getNumberContent(lines, 58);
	let lyricist = getNumberContent(lines, 59);
	let title    = getNumberContent(lines, 60);
	let meter    = getMeter(lines);
	let tempo    = getTempo(lines);

	let events = [];
	for (let i=0; i<lines.length; i++) {
		let line = lines[i];
		let matches = line.match(/^(\d+)/);
		let linetype = -1;
		if (matches) {
			linetype = parseInt(matches[1]);
		}
		if (linetype == 9) {
			let event = createDurationEvent(line);
			if (event) {
				events.push(event);
			}
		} else if (linetype == 14) {
			let event = createBarlineEvent(line);
			if (event) {
				events.push(event);
			}
		}
	}

	addBarlines(events, meter);

	let pitches = getPitches(events);

	console.log("EVENTS", events);
	// console.log("PITCHES", pitches);

	let output = "";
	if (title) {
		output += "!!!OTL: " + title + "\n";
	}
	if (composer) {
		output += "!!!COM: " + composer + "\n";
	}
	if (lyricist) {
		output += "!!!LYR: " + lyricist + "\n";
	}

	output += "**recip\t**ratio\n";

	if (meter) {
		output += "*M" + meter + "\t*I#25\n";
	} else {
		output += "*\t*Iclars\n";
	}

	if (tempo) {
		output += "*MM" + tempo + "\t*ref:C4\n";
	} else {
		output += "*\t*ref:C4\n";
	}

	for (let i=0; i<events.length; i++) {
		output += printEvent(events[i]);
	}
	output += "*-\t*-\n";

	output += printPitchRdf(pitches);

	return output;
}



//////////////////////////////
//
// addBarlines --
//

function addBarlines(events, meter) {
	let bardur = getMeasureDuration(meter);
	if (!bardur) {
		return;
	}
	if ((!events) || (events.length == 0)) {
		return;
	}
	let barnum = 2;
	let checker = new RationalNumber;
	// add measure 1 at start of score
	events[0].barnum = 1;
	let sum = new RationalNumber(0, 1);
	for (let i=0; i<events.length; i++) {
		let event = events[i];
		let edur = event.dur;
		sum.addTo(edur);
		checker = sum.divide(bardur);
		if (checker.getDenominator() === 1) {
			if (i < events.length - 1) {
				events[i+1].barnum = barnum++;
			}
		}
	}
}




//////////////////////////////
//
// printPitchRdf -- Using C4 as the reference for cents.
//

function printPitchRdf(pitches) {
	let tuning = {% include_relative tuning.json %};
	console.log("TUNING", tuning);
	let keys = Object.keys(pitches);
	let output      = "";
	let naturals    = [];
	let nonnaturals = [];

	for (let i=0; i<keys.length; i++) {
		let key = keys[i];
		let matches = key.match(/^([DFLMRS][aeio]l?)(\d)([bs#])?(\d)?/);
		if (!matches) {
			console.log("ERROR PROCESSING", key);
			continue;
		}
		let diatonic   = matches[1];
		let octave     = parseInt(matches[2]);
		let accidental = matches[3];
		let accsize    = parseInt(matches[4]);
		let eq53       = tuning[diatonic]
		eq53 += octave * 53;
		if (accidental) {
			if (accidental === "b") {
				eq53 -= accsize;
			} else if (accidental === "#") {
				eq53 += accsize;
			}
		}
		let diff53 = eq53 - 4 * 53;
		let cents = diff53 * 1200.0 / 53.0

		if (cents > 0) {
			cents = parseInt(cents * 100.0 + 0.5) / 100.0;
		} else {
			cents = -(parseInt(-cents * 100.0 + 0.5) / 100.0);
		}
		if (accidental) {
			nonnaturals[key] = cents;
		} else {
			naturals[key] = cents;
		}
	}


	// accidental substitutions need to go first:
	let nkeys = Object.keys(nonnaturals);
	for (let i=0; i<nkeys.length; i++) {
		output += "!!!RDF**ratio: ";
		output += nkeys[i];
		output += " = ";
		output += nonnaturals[nkeys[i]];
		output += "c";
		output += "\n";
	}

	nkeys = Object.keys(naturals);
	for (let i=0; i<nkeys.length; i++) {
		output += "!!!RDF**ratio: ";
		output += nkeys[i];
		output += " = ";
		output += naturals[nkeys[i]];
		output += "c";
		output += "\n";
	}

	return output;
}



//////////////////////////////
//
// printEvent --
//

function printEvent(event) {
	if (event.type != 9) {
		return "";
	}
	let output = "";
	if (typeof event.barnum !== "undefined") {
		output += "=" + event.barnum + "\t";
		output += "=" + event.barnum;
		output += "\n";
	}
	output += event.recip;
	output += "\t";
	if (event.rest) {
		output += 0;
	} else {
		output += event.pitch;
	}
	output += "\n";
	return output;
}



//////////////////////////////
//
// createBarlineEvent --
//

function createBarlineEvent(line) {
	return null;
	let fields = line.split(/\t/);
	let o = {};
	o.type = fields[0];
	return o;
}



//////////////////////////////
//
// createDurationEvent --
//

function createDurationEvent(line) {
	let fields = line.split(/\t/);
	let o = {};
	o.type = fields[0];
	if (fields[1]) {
		o.pitch = fields[1];
	} else {
		if (fields[2]) {
			o.rest = 1;
		} else {
			return null;
		}
	}
	if (fields[2]) {
		o.top = fields[2];
		o.bot = fields[3];
	} else {
		// grace note
		o.top = fields[2] || 0;
		o.bot = fields[3] || 1;
	}
	
	o.legato = fields[4];
	o.bas = fields[5];
	o.vel = fields[6];
	o.dur = new RationalNumber(o.top, o.bot);
	// verses
	// then floating-point version of rhythm.

	if (o.top == 1) {
		o.recip = o.bot;
	} else if (o.top == 3) {
		o.recip = parseInt(o.bot) / 2;
		o.recip += ".";
	}
	return o;
}



//////////////////////////////
//
// getNumberContent --
//

function getNumberContent(lines, number) {
	let regstring = "^" + number + "\\s*(.*)\\s*$";
	let re = new RegExp(regstring);
	for (let i=0; i<lines.length; i++) {
		let line = lines[i];
		let matches = re.exec(line);
		if (matches) {
			return matches[1];
		}
	}
	return "";
}


//////////////////////////////
//
// getMeter --
//

function getMeter(lines) {
	for (let i=0; i<lines.length; i++) {
		let line = lines[i];
		let matches = line.match(/^51\s+(\d+)\s+(\d+)/);
		if (matches) {
			return matches[1] + "/" + matches[2];
		}
	}
	return "";
}



//////////////////////////////
//
// getTempo -- Convert to quarter note units.
//

function getTempo(lines) {
	for (let i=0; i<lines.length; i++) {
		let line = lines[i];
		let matches = line.match(/^52\s+(\d+)\s+(\d+)\s+(\d+)/);
		if (matches) {
			let top = parseInt(matches[1]);
			let bot = parseInt(matches[2]);
			let tempo = parseInt(matches[3]);
			let num = new RationalNumber(top, bot);
			let quarter = new RationalNumber(1, 4);
			let factor = quarter.divide(num);
			let rtempo = new RationalNumber(tempo, 1);
			rtempo.divideTo(factor);
			return rtempo.toFloat();
		}
	}
	return "";
}



//////////////////////////////
//
// getPitches --
//

function getPitches(events) {
	let output = {};
	let pitch;
	for (let i=0; i<events.length; i++) {
		let event = events[i];
		if (event.type != 9) {
			continue;
		}
		if (event.pitch) {
			pitch = event.pitch;
		} else {
			continue;
		}
		if (!output[pitch]) {
			output[pitch] = 1;
		} else {
			output[pitch]++;
		}
	}
	return output;
}



//////////////////////////////
//
// Returns the duration of the measure in whole-note units.
//

function getMeasureDuration(meter) {
	let output = new RationalNumber(meter);
	return output;
}




</script>



